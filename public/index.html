<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Realtime To-Doï¼ˆBootstrapï¼‰</title>

  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous" />

  <!-- å®¢è£½æ¨£å¼ -->
  <link rel="stylesheet" href="/public/styles.css" />
  <script src="/utils/constants.js"></script>
</head>
<body>
  <div class="container-fluid min-vh-100 py-4 px-3 d-flex flex-column">
    <div class="row g-3 align-items-start flex-grow-1">
      <!-- To-Do å®¹å™¨ -->
      <div class="col-12 col-lg-8">
        <div class="todo-container w-75">
          <h2 class="mb-0 fs-1 fw-bold text-center">Realtime To-Do</h2>
          <div class="d-flex flex-row-reverse align-items-center justify-content-between mb-3">
            <span id="connState" class="badge text-bg-secondary">Disconnected</span>
          </div>

          <!-- æ–°å¢å¾…è¾¦ -->
          <form id="todoForm" class="mb-3" autocomplete="off">
            <div class="input-group">
              <input id="todoInput" type="text" class="form-control" placeholder="è¼¸å…¥å¾…è¾¦äº‹é …â€¦" aria-label="todo input" />
              <button class="btn btn-primary" type="submit">æ–°å¢</button>
              <button class="ms-1 btn btn-danger" type="button" id="btnClearAll">åˆªé™¤å…¨éƒ¨</button>
            </div>
          </form>

          <!-- æ¸…å–® -->
          <ul id="todoList" class="list-group mb-2"></ul>

          <!-- ç©ºæ¸…å–®æç¤º -->
          <div id="emptyHint" class="alert alert-secondary d-none mb-0">
            ç›®å‰æ²’æœ‰å¾…è¾¦äº‹é …
          </div>
        </div>
      </div>

      <!-- Chat Room å®¹å™¨ -->
      <div class="col-12 col-lg-4 d-flex flex-column">
        <div class="chat-room-container px-5 d-flex flex-column flex-grow-1">
          <h2 class="mb-1 fs-1 fw-bold text-center">Chat Room</h2>

          <!-- åƒæ‰å‰©é¤˜é«˜åº¦ã€å…§å®¹å¤šæ‰æ»¾å‹• -->
          <div class="chat flex-grow-1 overflow-auto"></div>

          <form id="messageForm" class="mt-2 d-flex gap-2">
            <input type="text" id="messageBox" class="form-control" placeholder="Type your message here" />
            <button id="send" class="btn btn-primary" title="Send" type="submit">â¤</button>
          </form>
        </div>
      </div>
    </div>
  </div>

  <script>
    const { TODO_MESSAGE_TYPES, CHAT_MESSAGE_TYPES } = window.CHAT_CONSTANTS;

    // ===== DOM =====
    // To-Do
    const form = document.querySelector('#todoForm');
    const input = document.querySelector('#todoInput');
    const list = document.querySelector('#todoList');
    const emptyHint = document.querySelector('#emptyHint');
    const connState = document.querySelector('#connState');

    // Chat
    const chat = document.querySelector('.chat');
    const messageBox = document.querySelector('#messageBox');
    const messageForm = document.querySelector('#messageForm');

    // ===== ç‹€æ…‹ =====
    let wsClient = null;
    let todos = [];
    // const currentUser = "User" + Math.floor(Math.random() * 1000);
    let currentUser = prompt("è«‹è¼¸å…¥ä½¿ç”¨è€…åç¨±ï¼š")?.trim();
    if (!currentUser) {
      currentUser = "User" + Math.floor(Math.random() * 1000);
    }



    // ===== é€£ç·š =====
    const wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
    wsClient = new WebSocket(`${wsProtocol}://${location.host}/ws`);

    wsClient.onopen = () => {
      setConnState('Connected', 'success');

      // å‚³é€ä½¿ç”¨è€…åç¨±
      wsClient.send(JSON.stringify({
        type: CHAT_MESSAGE_TYPES.SET_USERNAME,
        payload: { username: currentUser }
      }));

      // å»£æ’­æœ‰äººåŠ å…¥èŠå¤©å®¤ï¼ˆå¯é¸ï¼‰
      wsClient.send(JSON.stringify({ type: CHAT_MESSAGE_TYPES.NEW_USER }));
    };
    wsClient.onclose = () => setConnState('Disconnected', 'secondary');
    wsClient.onerror = () => setConnState('Error', 'danger');

    wsClient.onmessage = (ev) => {


      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }
      const { type, payload } = msg || {};

      switch (type) {
        // ===== To-Do =====
        case TODO_MESSAGE_TYPES.INIT: {
          todos = payload?.todos || [];
          render();
          break;
        }
        case TODO_MESSAGE_TYPES.TODO_ADDED: {
          // const { todo } = payload || {};
          const todo = payload;
          if (!todo) return;
          if (!todos.some((t) => t.id === todo.id)) todos.push(todo);
          render();
          break;
        }
        case TODO_MESSAGE_TYPES.TODO_UPDATED: {
          // const { todo } = payload || {};
          const todo = payload;
          if (!todo) return;
          const idx = todos.findIndex((t) => t.id === todo.id);
          if (idx !== -1) todos[idx] = todo;
          render();
          break;
        }
        case TODO_MESSAGE_TYPES.TODO_DELETED: {
          const id = Number(payload?.id);
          todos = todos.filter((t) => t.id !== id);
          render();
          break;
        }
        case TODO_MESSAGE_TYPES.DELETE_ALL_TODO: {
          todos = [];
          render();
          break;
        }

        case TODO_MESSAGE_TYPES.TODO_LOCKED: {
          const { id, user } = payload || {};
          const idx = todos.findIndex(t => t.id === id);
          if (idx !== -1) {
            todos[idx].lockedBy = user;
            // render();

            // æ­£åœ¨ç·¨è¼¯çš„ä½¿ç”¨è€…æ‰éœ€è¦å‘¼å« render é‡æ–°æ¸²æŸ“
            // ç·¨è¼¯è€…å‰‡ä¸ç”¨
            // ç·¨è¼¯å®Œç•¢å†é  TODO_UPDATED é€™å€‹ case çš„ render åˆ·æ–°å³å¯
            if (user !== currentUser) render();
          }
          break;
        }

        case TODO_MESSAGE_TYPES.TODO_UNLOCKED: {
          const { id } = payload || {};
          const idx = todos.findIndex(t => t.id === id);
          if (idx !== -1) {
            todos[idx].lockedBy = null;
            render();
          }
          break;
        }

        // ===== Chat =====
        case CHAT_MESSAGE_TYPES.NEW_USER:
          showMessageReceived(`<span class="badge rounded-pill text-bg-success">ğŸ«¶ ${payload?.username} åŠ å…¥èŠå¤©å®¤</span>`, true);
          break;

        case CHAT_MESSAGE_TYPES.NEW_MESSAGE:
          showMessageReceived(`${payload?.username ?? 'åŒ¿å'}: ${payload?.message ?? ''}`);
          break;

        default:
          break;
      }
    };

    function setConnState(text, style) {
      connState.textContent = text;
      connState.className = 'badge';
      connState.classList.add(`text-bg-${style}`);
    }

    // æ–°å¢å¾…è¾¦
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const text = (input.value || '').trim();
      if (!text || wsClient.readyState !== WebSocket.OPEN) return;
      wsClient.send(JSON.stringify({ type: TODO_MESSAGE_TYPES.ADD_TODO, payload: { text } }));
      input.value = '';
      input.focus();
    });

    // åˆªé™¤å…¨éƒ¨
    document.querySelector('#btnClearAll').onclick = () => {
      if (!wsClient || wsClient.readyState !== WebSocket.OPEN) return;
      wsClient.send(JSON.stringify({ type: TODO_MESSAGE_TYPES.DELETE_ALL_TODO, payload: {} }));
    };

    // åˆ‡æ›å®Œæˆ
    list.addEventListener('change', (e) => {
      const el = e.target;
      if (el.matches('input[type="checkbox"][data-id]')) {
        const id = Number(el.dataset.id);
        if (wsClient.readyState === WebSocket.OPEN) {
          wsClient.send(JSON.stringify({ type: TODO_MESSAGE_TYPES.TOGGLE_TODO, payload: { id } }));
        }
      }
    });

    // åˆªé™¤ & ç·¨è¼¯å–®ç­†    
    list.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-id]');
      if (!btn) return;
      const id = Number(btn.dataset.id);
      const action = btn.dataset.action;
      const li = btn.closest('li');

      if (action === 'delete') {
        if (wsClient.readyState === WebSocket.OPEN) {
          wsClient.send(JSON.stringify({ type: TODO_MESSAGE_TYPES.DELETE_TODO, payload: { id } }));
        }
        return;
      }

      if (action === 'edit') {
        enterEditMode(li, id);
        return;
      }

      if (action === 'save') {
        const input = li.querySelector('input.form-control[data-role="edit-input"]');
        const newText = (input?.value || '').trim();
        if (!newText) { input?.focus(); return; }
        if (wsClient.readyState === WebSocket.OPEN) {
          wsClient.send(JSON.stringify({
            type: TODO_MESSAGE_TYPES.UPDATE_TODO,
            payload: { id, text: newText }
          }));
        }
        // äº¤çµ¦ä¼ºæœå™¨å»£æ’­ TODO_UPDATED å¾Œå† render()
        // ç‚ºé¿å…è·³å‹•ï¼Œå¯å…ˆé›¢é–‹ç·¨è¼¯æ…‹ï¼ˆUI æœƒè¢«å¾ŒçºŒ render è¦†è“‹ï¼‰
        // unlock äº¤çµ¦é€™è£¡
        exitEditMode(li);
        return;
      }

      if (action === 'cancel') {
        exitEditMode(li);
        return;
      }
    });

    // ç·¨è¼¯ä¹‹ enterEditMode
    function enterEditMode(li, id) {
      if (!li || li.dataset.editing === '1') return;
      li.dataset.editing = '1';

      // ====== ğŸ”’ é€™è£¡é€ LOCK ======
      if (wsClient.readyState === WebSocket.OPEN) {
        wsClient.send(JSON.stringify({
          type: TODO_MESSAGE_TYPES.LOCK_TODO,
          payload: { id, user: currentUser }
        }));
      }

      const left = li.querySelector('.form-check');
      const label = left?.querySelector('label.form-check-label');
      const chk = left?.querySelector('input[type="checkbox"]');
      if (chk) chk.disabled = true;

      const currentText = label?.textContent || '';

      // å»ºç«‹ç·¨è¼¯å€å¡Šï¼ˆè¼¸å…¥æ¡† + å„²å­˜/å–æ¶ˆï¼‰
      const editor = document.createElement('div');
      editor.className = 'input-group input-group-sm';
      editor.dataset.role = 'editor';

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'form-control';
      input.value = currentText;
      input.dataset.role = 'edit-input';
      input.setAttribute('aria-label', 'edit todo text');

      const btnSave = document.createElement('button');
      btnSave.type = 'button';
      btnSave.className = 'btn btn-success';
      btnSave.textContent = 'å„²å­˜';
      btnSave.dataset.id = id;
      btnSave.dataset.action = 'save';

      const btnCancel = document.createElement('button');
      btnCancel.type = 'button';
      btnCancel.className = 'btn btn-outline-light';
      btnCancel.textContent = 'å–æ¶ˆ';
      btnCancel.dataset.id = id;
      btnCancel.dataset.action = 'cancel';

      editor.appendChild(input);
      editor.appendChild(btnSave);
      editor.appendChild(btnCancel);

      // éš±è—åŸæœ¬çš„ labelï¼Œæ’å…¥ editor
      label?.classList.add('d-none');
      left?.appendChild(editor);

      // èšç„¦åˆ°è¼¸å…¥æ¡†
      input.focus();
      // è®“ Enter = å„²å­˜ã€Esc = å–æ¶ˆï¼ˆé«”é©—æ›´å¥½ï¼‰
      input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') btnSave.click();
        if (ev.key === 'Escape') btnCancel.click();
      });
    }

    // ç·¨è¼¯ä¹‹ exitEditMode
    function exitEditMode(li) {
      if (!li) return;

      const id = Number(li.querySelector('button[data-action="edit"]')?.dataset.id);
      if (id && wsClient.readyState === WebSocket.OPEN) {
        wsClient.send(JSON.stringify({ type: TODO_MESSAGE_TYPES.UNLOCK_TODO, payload: { id } }));
      }

      li.dataset.editing = '0';

      const left = li.querySelector('.form-check');
      const label = left?.querySelector('label.form-check-label');
      const chk = left?.querySelector('input[type="checkbox"]');
      const editor = left?.querySelector('[data-role="editor"]');

      if (editor) editor.remove();
      label?.classList.remove('d-none');
      if (chk) chk.disabled = false;
    }


    // ç¹ªè£½å¾…è¾¦äº‹é …æ¸…å–®ï¼ˆBootstrap ç‰ˆï¼‰
    function render() {
      list.innerHTML = '';

      const items = todos.slice().sort((a, b) => {
        const doneDiff = Number(a.completed) - Number(b.completed);
        if (doneDiff !== 0) return doneDiff;
        if (a.createdAt != null && b.createdAt != null) {
          return b.createdAt - a.createdAt;
        }
        return 0;
      });

      if (items.length === 0) {
        emptyHint.classList.remove('d-none');
        return;
      }
      emptyHint.classList.add('d-none');

      for (const t of items) {
        const li = document.createElement('li');
        li.className = 'list-group-item d-flex align-items-center justify-content-between bg-dark';

        const left = document.createElement('div');
        left.className = 'form-check d-flex align-items-center gap-2 mb-0';

        const chk = document.createElement('input');
        chk.className = 'form-check-input';
        chk.type = 'checkbox';
        chk.checked = !!t.completed;
        chk.dataset.id = t.id;

        const label = document.createElement('label');
        label.className = 'form-check-label mb-0 text-white';
        label.textContent = t.text || '';
        if (t.completed) label.classList.add('text-decoration-line-through');

        left.appendChild(chk);
        left.appendChild(label);

        // å³å´ï¼šå‹•ä½œæŒ‰éˆ•å€
        const actions = document.createElement('div');

        // ç·¨è¼¯æŒ‰éˆ•        
        const edit = document.createElement('button');
        edit.type = 'button';
        edit.className = 'btn btn-sm btn-warning me-2';
        edit.textContent = 'ç·¨è¼¯';
        edit.dataset.id = t.id;
        edit.dataset.action = 'edit';

        // åˆªé™¤æŒ‰éˆ•
        const del = document.createElement('button');
        del.type = 'button';
        del.className = 'btn btn-sm btn-danger';
        del.textContent = 'åˆªé™¤';
        del.dataset.id = t.id;
        del.dataset.action = 'delete';

        // è‹¥è¢«é–å®šå°± disable
        if (t.lockedBy && t.lockedBy !== currentUser) {
          label.textContent += `ï¼ˆ${t.lockedBy} ç·¨è¼¯ä¸­ï¼‰`;
          chk.disabled = true;
          edit.disabled = true;
          del.disabled = true;
        }

        actions.appendChild(edit);
        actions.appendChild(del);

        li.appendChild(left);
        li.appendChild(actions);
        list.appendChild(li);
      }

    }

    // ===== Chatï¼šé€è¨Šæ¯ï¼ˆä¿æŒæœ€å°åŠŸèƒ½ï¼‰=====
    messageForm.addEventListener('submit', (e) => {
      e.preventDefault();
      const message = messageBox.value.trim();
      if (!message) return;

      if (wsClient.readyState !== WebSocket.OPEN) {
        showMessageReceived('<span class="text-danger">âŒ å°šæœªé€£ç·š</span>', true);
        return;
      }

      // ç«‹å³é¡¯ç¤ºè‡ªå·±é€å‡ºçš„è¨Šæ¯
      showMessageSent(message);
      messageBox.value = '';

      // å‚³çµ¦ä¼ºæœå™¨ï¼ˆç”±ä¼ºæœå™¨è½‰æ’­çµ¦å…¶ä»–äººï¼‰
      wsClient.send(JSON.stringify({
        type: CHAT_MESSAGE_TYPES.NEW_MESSAGE,
        payload: { message }
      }));
    });


    // ===== Chat UI helpers =====
    function showMessageSent(message) { showNewMessage(message, 'sending', false); }
    function showMessageReceived(message, isSystem = false) { showNewMessage(message, 'receiving', isSystem); }
    function showNewMessage(message, className, isSystem = false) {
      const bubble = document.createElement('div');
      if (isSystem) {
        bubble.innerHTML = message; // ç³»çµ±è¨Šæ¯ï¼šå®‰å…¨ä¾†æº
      } else {
        bubble.textContent = message; // ä½¿ç”¨è€…è¼¸å…¥ï¼šé˜²æ­¢ XSS
      }
      bubble.className = 'messageBubble';
      const messageWrapper = document.createElement('div');
      messageWrapper.className = 'messageWrapper ' + className;
      messageWrapper.appendChild(bubble);
      chat.appendChild(messageWrapper);
      chat.scrollTop = chat.scrollHeight;
    }
  </script>
</body>
</html>